import os
os.environ['TF_ENABLE_ONEDNN_OPTS'] = '0'
import tensorflow as tf
import tensorflow_probability as tfp
tfd = tfp.distributions
tf.random.set_seed(123)

from .model import norm_rvs

##########################
# Standard Kalman Filter # 
##########################

class KalmanFilters: 
    
    def __init__(self, y, model=None, A=None, B=None, V=None, W=None,  muy=None):
        self.y = y
        self.nTimes, self.ndims     = y.shape 
        self.model                  = "LG" if model is None else model
        A                           = tf.eye(self.ndims, dtype=tf.float64) if A is None else A
        B                           = tf.eye(self.ndims, dtype=tf.float64) if B is None else B
        V                           = tf.eye(self.ndims, dtype=tf.float64) if V is None else V
        W                           = tf.eye(self.ndims, dtype=tf.float64) if W is None else W
        self.mu0                    = tf.zeros((self.ndims,), dtype=tf.float64)
        self.Sigma0                 = tf.eye(self.ndims, dtype=tf.float64)
    
def KF_Predict(x_prev, P_prev, A, V):
    "Predict and return the system state and covariance matrix, x and P, given the previous, x_prev and P_prev."
    x               = tf.linalg.matvec(A, x_prev)
    P               = A @ P_prev @ tf.transpose(A) + V
    return x, P 

def KF_Gain(P, B, W):
    "Compute and return the standard Kalman gain."
    M               = P @ tf.transpose(B) 
    Minv            = tf.linalg.inv(B @ M + W) 
    return M @ Minv

def KF_Filter(x_prev, P_prev, y_obs, y_prev, B, K):
    "Filter the predicted system state and covariance matrix, x_prev and P_prev, using the Kalman gain and observed measurments, K and y_obs."
    x               = x_prev + tf.linalg.matvec(K, y_obs - y_prev)
    P               = P_prev - P_prev @ tf.transpose(B) @ tf.transpose(K)
    return x, P

def KalmanFilter(y, A=None, B=None, V=None, W=None, mu0=None, Sigma0=None):
    """
    Compute the estimated states using the standard Kalman Filter given the measurements. 

    Keyword args:
    -------------
    y : tf.Variable of float64 with dimension (nTimes,ndims). The measurements generated by LGSSM. 
    A : tf.Tensor of float64 with shape (ndims,ndims), optional. The transition matrix. Defaults to identity matrix if not provided.
    B : tf.Tensor of float64 with shape (ndims,ndims), optional. The output matrix. Defaults to identity matrix if not provided.
    V : tf.Tensor of float64 with shape (ndims,ndims), optional. The system noise matrix. Defaults to identity matrix if not provided.
    W : tf.Tensor of float64 with shape (ndims,ndims), optional. The measurement noise matrix. Defaults to identity matrix if not provided.
    mu0 : tf.Tensor of float64 with shape (ndims,), optional. The prior mean for initial state. Defaults to zeros if not provided.
    Sigma0 : tf.Tensor of float64 with shape (ndims,ndims), optional. The prior covariance for initial state. Defaults to identity matrix if not provided.

    Returns:
    --------
    X_filtered : tf.Variable of float64 with dimension (nTimes,ndims). The filtered states given by the standard Kalman Filter. 
    """
    nTimes, ndims   = y.shape 
    mu0             = tf.zeros((ndims,), dtype=tf.float64) if mu0 is None else mu0
    Sigma0          = tf.eye(ndims, dtype=tf.float64) if Sigma0 is None else Sigma0
    A               = tf.eye(ndims, dtype=tf.float64) if A is None else A
    B               = tf.eye(ndims, dtype=tf.float64) if B is None else B
    V               = tf.eye(ndims, dtype=tf.float64) if V is None else V
    W               = tf.eye(ndims, dtype=tf.float64) if W is None else W
    
    X_filtered      = tf.Variable(tf.zeros((nTimes, ndims), dtype=tf.float64))
    x_prev          = norm_rvs(ndims, mu0, Sigma0) 
    P_prev          = A @ Sigma0 @ tf.transpose(A) + V

    for i in range(nTimes):
        x_pred, P_pred     = KF_Predict(x_prev, P_prev, A, V)
        K                  = KF_Gain(P_pred, B, W)
        y_pred             = tf.linalg.matvec(B, x_pred)
        x_filt, P_filt     = KF_Filter(x_pred, P_pred, y[i,:], y_pred, B, K)
        x_prev, P_prev     = x_filt, P_filt        
        X_filtered[i,:].assign(x_prev)  
        
    return X_filtered
